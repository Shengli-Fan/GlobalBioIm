

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Important Informations &mdash; GlobalBioIm Library 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="GlobalBioIm Library 1.0 documentation" href="index.html"/>
        <link rel="next" title="Examples" href="examples.html"/>
        <link rel="prev" title="Welcome to the GlobalBioIm Library webpage!" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> GlobalBioIm Library
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">General</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference external" href="https://github.com/Biomedical-Imaging-Group/GlobalBioIm">Download or Clone (v 1.0)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Important Informations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general-philosophy">General Philosophy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classes-hierarchy">Classes Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interface-methods-and-core-methods">Interface methods and Core methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memoize-and-precomputation-options">Memoize and Precomputation options</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compositions">Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#auxiliary-utilities">Auxiliary Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#use-the-provided-templates">Use the provided templates!</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="conditionsuse.html">Conditions of Use</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="abstract.html">Abstract classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="linop.html">Linear Operators (LinOp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nonlinop.html">Non-Linear Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="cost.html">Cost Functions (Cost)</a></li>
<li class="toctree-l1"><a class="reference internal" href="opti.html">Optimization Algorithms (Opti)</a></li>
<li class="toctree-l1"><a class="reference internal" href="methodssummary.html">List of Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="propertiessummary.html">List of Properties</a></li>
</ul>
<p class="caption"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="http://bigwww.epfl.ch">Biomedical Imaging Group</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GlobalBioIm Library</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Important Informations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/infos.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="important-informations">
<h1>Important Informations<a class="headerlink" href="#important-informations" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>This section contains useful informations for developers/users who want to</dt>
<dd><ul class="first last simple">
<li>Implement new classes <code class="xref py py-class docutils literal"><span class="pre">Map</span></code>, <code class="xref py py-class docutils literal"><span class="pre">LinOp</span></code>, <code class="xref py py-class docutils literal"><span class="pre">Cost</span></code> or <code class="xref py py-class docutils literal"><span class="pre">Opti</span></code>,</li>
<li>Implement new tools in existing classes (e.g. a fast computation of the gradient of a cost),</li>
<li>Use the library for practical problems (see also the provided <a class="reference internal" href="examples.html#ref-examples"><span class="std std-ref">examples</span></a>)</li>
</ul>
</dd>
</dl>
<div class="section" id="general-philosophy">
<h2>General Philosophy<a class="headerlink" href="#general-philosophy" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>The implementation and organization of the library is guided by the following principles:</dt>
<dd><ul class="first last simple">
<li>Low code duplication,</li>
<li>Implementing a new map/cost/algorithm should require to edit/create only one file,</li>
<li>There should be a solution for implementing new needs (i.e. few hard constraints to respect in implementations),</li>
<li>Always have the choice between fast but memory consuming / memory efficient but slower.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="classes-hierarchy">
<h2>Classes Hierarchy<a class="headerlink" href="#classes-hierarchy" title="Permalink to this headline">¶</a></h2>
<p>The Library is based on 4 abstract classes <code class="xref py py-class docutils literal"><span class="pre">Map</span></code>,  <code class="xref py py-class docutils literal"><span class="pre">LinOp</span></code>,  <code class="xref py py-class docutils literal"><span class="pre">Cost</span></code> and  <code class="xref py py-class docutils literal"><span class="pre">Opti</span></code> from which
inherit all the classes used in practice to solve inverse problems. Note that non-linear operators inherit directly from the
<code class="xref py py-class docutils literal"><span class="pre">Map</span></code> class since they do not require new specific attributes/methods.</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="_images/ClassesHierarchy.png"><img alt="Classes Hierarchy diagram" src="_images/ClassesHierarchy.png" style="width: 1002.4px; height: 537.6px;" /></a>
<p class="caption"><span class="caption-text">Fig 1. Classes Hierarchy diagram of the GlobalBioIm Library.</span></p>
</div>
</div>
<div class="section" id="interface-methods-and-core-methods">
<h2>Interface methods and Core methods<a class="headerlink" href="#interface-methods-and-core-methods" title="Permalink to this headline">¶</a></h2>
<p>Classes (except <code class="xref py py-class docutils literal"><span class="pre">Opti</span></code> classes) contain two types of methods:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Interface methods</strong> which are methods that can be called from an instanciated object of the class. They check the size conformity of the inputs and call the corresponding core method. Morever, they
manage the memoize mechanism (see below). Their implementation is done at the level of abstract classes. Hence, to implement a new class, developpers do not have to deal with the memoize system as well as the checking of inputs sizes.</li>
<li><strong>Core methods</strong>  are  methods that contain implementation. Developpers only need to implement these methods.</li>
</ul>
</div></blockquote>
<p>Hence, methods always go by pairs (Interface + Core). They have the same name which is followed by an “_” symbol for core ones.
For instance</p>
<blockquote>
<div><ul class="simple">
<li>apply()</li>
<li>apply_()</li>
</ul>
</div></blockquote>
<p><strong>Note</strong> There is an exception for the <code class="xref py py-meth docutils literal"><span class="pre">mtimes()</span></code> method (i.e. the overloading of the * operator) which do not have
an associated <em>core</em> method.  This method calls either <code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">makeComposition()</span></code> depending on the
right hand side of the operation.</p>
</div>
<div class="section" id="memoize-and-precomputation-options">
<h2>Memoize and Precomputation options<a class="headerlink" href="#memoize-and-precomputation-options" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>The <code class="xref py py-class docutils literal"><span class="pre">Map</span></code> class provides two attributes which are</dt>
<dd><ul class="first last simple">
<li><code class="xref py py-attr docutils literal"><span class="pre">memoizeOpts</span></code> a structure of booleans with one field per method of the class (default all false). If, for instance,
the field <em>memoizeOpts.apply</em> is set to true, the result of the <code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code> method \(\mathrm{y=Hx}\) is saved.
Then, if the next call to the <code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code> method is for the same \(\mathrm{x}\), the saved value \(\mathrm{y}\) is directly
returned without any computation.</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">doPrecomputation</span></code> a boolean (default false). When <em>true</em>, some methods of the instanciated
object will be accelerated at the price of a larger memory consumption. It depends on how the implementation of
the class has been done. Hence, if one wants to accelerate a method thanks to a precomputation of some quatities, this
has to be done <strong>when the doPrecomputation option is activated</strong>, and not by default. This let the possibility to
avoid the precomputation in case of memory limitation issues.</li>
</ul>
</dd>
</dl>
<p>Let us look at some examples. Consider a convolution oprerator <code class="xref py py-class docutils literal"><span class="pre">LinOpConv</span></code></p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="n">H</span><span class="o">=</span><span class="n">LinOpConv</span><span class="p">(</span><span class="n">fftn</span><span class="p">(</span><span class="n">psf</span><span class="p">));</span>
<span class="n">H</span><span class="o">.</span><span class="n">memoizeOpts</span><span class="o">.</span><span class="n">apply</span><span class="o">=</span><span class="n">true</span><span class="p">;</span>
</pre></div>
</div>
<p>for a given PSF (\(512\times 512 \times 256 \)) and for which we activate the memoize option for the <code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code> method.
Then, let us make the following calls to <code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code> method.</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">psf</span><span class="p">));</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="n">H</span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">2.414025</span> <span class="n">seconds</span><span class="o">.</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="n">H</span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">0.085205</span> <span class="n">seconds</span><span class="o">.</span>
<span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="n">H</span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">2.465424</span> <span class="n">seconds</span><span class="o">.</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="n">H</span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">0.083087</span> <span class="n">seconds</span><span class="o">.</span>
</pre></div>
</div>
<p>Here, one can appreciate the effect of the <em>memoize</em> option. To observe the effect of the <em>precomputation</em> option,
we instantiate a <code class="xref py py-class docutils literal"><span class="pre">CostL2</span></code> object and we combine it with our convolution operator. Moreover, we activate the <em>precomputation</em> option for the resulting <code class="xref py py-class docutils literal"><span class="pre">CostL2Composition</span></code> object.</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">y</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">psf</span><span class="p">));</span>
<span class="o">&gt;&gt;</span> <span class="n">LS</span><span class="o">=</span><span class="n">CostL2</span><span class="p">([],</span><span class="n">y</span><span class="p">);</span>
<span class="o">&gt;&gt;</span> <span class="n">F</span><span class="o">=</span><span class="n">LS</span><span class="o">*</span><span class="n">H</span><span class="p">;</span>
<span class="o">&gt;&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">doPrecomputation</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Let us evaluate the gradient of the cost <em>F</em> at a point x.</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">x</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">psf</span><span class="p">));</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">g</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">applyGrad</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">5.236043</span> <span class="n">seconds</span><span class="o">.</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">g</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">applyGrad</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">2.554012</span> <span class="n">seconds</span><span class="o">.</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">g</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">applyGrad</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">2.572284</span> <span class="n">seconds</span><span class="o">.</span>
</pre></div>
</div>
<p>For a <code class="xref py py-class docutils literal"><span class="pre">CostL2</span></code>, when the <em>precomputation</em> option is activated, the gradient is computed using</p>
<p>$$ \nabla F(\mathrm{x})= \mathrm{H^*Hx - H^*y},$$</p>
<p>which allows to take benefit from a fast implementation of \( \mathrm{H^*H}\) (for the above example \( \mathrm{H^*H}\) is also a
convolution). Here, at the first call of <code class="xref py py-meth docutils literal"><span class="pre">applyGrad()</span></code>, the quantity \(\mathrm{H^*y}\) is computed and stored
(hence 4 FFT/IFFT are performed). Then, for all the following calls to <code class="xref py py-meth docutils literal"><span class="pre">applyGrad()</span></code> the compuation is now reduced to
the application of \( \mathrm{H^*H}\) which requires only 2 FFT/IFFT in this case.</p>
<p>Note that in the above example we computed the gradient 3 times over the same x without activating the <em>memoize</em> option
for the <code class="xref py py-meth docutils literal"><span class="pre">applyGrad()</span></code> method in order to show the effect of <em>precomputation</em>. Of course, doing new calls to <code class="xref py py-meth docutils literal"><span class="pre">applyGrad()</span></code>
with the same x after having activated the <em>memoize</em> option produces,</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">memoizeOpts</span><span class="o">.</span><span class="n">applyGrad</span><span class="o">=</span><span class="n">true</span><span class="p">;</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">g</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">applyGrad</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">2.572987</span> <span class="n">seconds</span><span class="o">.</span>
<span class="o">&gt;&gt;</span> <span class="n">tic</span><span class="p">;</span><span class="n">g</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">applyGrad</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">toc</span><span class="p">;</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="ow">is</span> <span class="mf">0.075061</span> <span class="n">seconds</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="compositions">
<h2>Compositions<a class="headerlink" href="#compositions" title="Permalink to this headline">¶</a></h2>
<p>The library enjoys a nice operator algebra mechanism which allows for generic implementations. This is made possible
thanks to the methods prefixed by <em>make</em> (i.e. <code class="xref py py-meth docutils literal"><span class="pre">makeComposition_()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">makeAdjoint_()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">makeHtH_()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">makeHHt_()</span></code>…)
as well as the <code class="xref py py-meth docutils literal"><span class="pre">plus_()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">minus_()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">mpower_()</span></code> methods. By default these methods will instanciate  <a class="reference internal" href="abstract.html#ref-op-on-maps"><span class="std std-ref">Operations on Maps</span></a> objects which may lose some properties such as the invertibility or
some fast implementations (due to the genericity of these classes). However, developers can reimplement these <em>make</em> methods
in derived classes. For instance in <code class="xref py py-class docutils literal"><span class="pre">LinOpConv</span></code>, one can find</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span>function M = plus_(this,G)
   % Reimplemented from parent class :class:`LinOp`.
   if isa(G,&#39;LinOpDiag&#39;) &amp;&amp; G.isScaledIdentity
      M=LinOpConv(G.diag+this.mtf,this.isReal,this.index);
   elseif isa(G,&#39;LinOpConv&#39;)
      M=LinOpConv(this.mtf+G.mtf,this.isReal,this.index);
   else
      M=plus_@LinOp(this,G);
   end
end
function M = minus_(this,G)
   % Reimplemented from parent class :class:`LinOp`.
   if isa(G,&#39;LinOpDiag&#39;)  &amp;&amp; G.isScaledIdentity
      M=LinOpDiag(this.mtf-G.diag,this.isReal,this.index);
   elseif isa(G,&#39;LinOpConv&#39;)
      M=LinOpConv(this.mtf-G.mtf,this.isReal,this.index);
   else
      M=minus_@LinOp(this,G);
   end
end
function M = makeHHt_(this)
   % Reimplemented from parent class :class:`LinOp`.
   M=LinOpConv(abs(this.mtf).^2,this.isReal,this.index);
end
function M = makeHtH_(this)
   % Reimplemented from parent class :class:`LinOp`.
   M=LinOpConv(abs(this.mtf).^2,this.index);
end
function G = makeComposition_(this, H)
   % Reimplemented from parent class :class:`LinOp`
   if isa(H, &#39;LinOpConv&#39;)
       G = LinOpConv(this.mtf.*H.mtf,this.isReal,this.index);
   elseif isa(H,&#39;LinOpDiag&#39;) &amp;&amp; H.isScaledIdentity
       G = LinOpConv(this.mtf.*H.diag,this.isReal,this.index);
   else
       G = makeComposition_@LinOp(this, H);
   end
end
</pre></div>
</div>
<p>which all instanciate a new <code class="xref py py-class docutils literal"><span class="pre">LinOpConv</span></code> with the proper kernel. Hence considering a <code class="xref py py-class docutils literal"><span class="pre">LinOpConv</span></code>,</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">H</span><span class="o">=</span><span class="n">LinOpConv</span><span class="p">(</span><span class="n">fft2</span><span class="p">(</span><span class="n">psf</span><span class="p">))</span>

<span class="n">H</span> <span class="o">=</span>

  <span class="n">LinOpConv</span> <span class="k">with</span> <span class="n">properties</span><span class="p">:</span>

             <span class="n">mtf</span><span class="p">:</span> <span class="p">[</span><span class="mi">256</span><span class="n">x256</span> <span class="n">double</span><span class="p">]</span>
           <span class="n">index</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">Notindex</span><span class="p">:</span> <span class="p">[]</span>
            <span class="n">ndms</span><span class="p">:</span> <span class="mi">2</span>
          <span class="n">isReal</span><span class="p">:</span> <span class="mi">1</span>
            <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;LinOpConv&#39;</span>
    <span class="n">isInvertible</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">isDifferentiable</span><span class="p">:</span> <span class="mi">1</span>
          <span class="n">sizein</span><span class="p">:</span> <span class="p">[</span><span class="mi">256</span> <span class="mi">256</span><span class="p">]</span>
         <span class="n">sizeout</span><span class="p">:</span> <span class="p">[</span><span class="mi">256</span> <span class="mi">256</span><span class="p">]</span>
            <span class="n">norm</span><span class="p">:</span> <span class="mf">1.0000</span>
     <span class="n">memoizeOpts</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="n">x1</span> <span class="n">struct</span><span class="p">]</span>
<span class="n">doPrecomputation</span><span class="p">:</span> <span class="mi">0</span>
</pre></div>
</div>
<p>the \(\mathrm{H^*H} \) is also a <code class="xref py py-class docutils literal"><span class="pre">LinOpConv</span></code></p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span>&gt;&gt; H&#39;*H

ans =

    LinOpConv with properties:

             mtf: [256x256 double]
           index: [1 2]
        Notindex: [1?0 double]
            ndms: 2
          isReal: 1
            name: &#39;LinOpConv&#39;
    isInvertible: 0
isDifferentiable: 1
          sizein: [256 256]
         sizeout: [256 256]
            norm: 0.9999
     memoizeOpts: [1x1 struct]
doPrecomputation: 0
</pre></div>
</div>
<p>and the same holds for the \(\mathrm{H^*H + I} \) operator</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span>&gt;&gt; I=LinOpIdentity(size(psf));
&gt;&gt; H&#39;*H+I

    ans =

        LinOpConv with properties:

             mtf: [256x256 double]
           index: [1 2]
        Notindex: [1?0 double]
            ndms: 2
          isReal: 1
            name: &#39;LinOpConv&#39;
    isInvertible: 1
isDifferentiable: 1
          sizein: [256 256]
         sizeout: [256 256]
            norm: 1.9999
     memoizeOpts: [1x1 struct]
doPrecomputation: 0
</pre></div>
</div>
<p>which is invertible in comparison to \(\mathrm{H}\) and \(\mathrm{H^*H}\). This nice combination mechanism allows
for  generic implementations. For instance, there is a property stating that, given the proximity
operator of a convex function \(f\),  the proximity operator of \(f(\mathrm{H}\cdot)\), for \(\mathrm{H}\) a
semi-orthogonal linear operator (i.e. \(\mathrm{HH^*}= \nu \mathrm{I}\) for \(\nu &gt;0\)), is given by</p>
<p>$$ \mathrm{prox}_{f(\mathrm{H}\cdot)}(\mathrm{x}) = \mathrm{x} + \nu^{-1}\mathrm{H^*} \left( \mathrm{prox}_{\nu f}(\mathrm{Hx}) -\mathrm{Hx} \right) $$</p>
<p>Hence, at the level of <code class="xref py py-class docutils literal"><span class="pre">CostComposition</span></code> one can check if \(\mathrm{H}\)  is a semi-orthogonal linear operator
and implement in a generic way the above property. In the constructor,</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">H2</span><span class="o">*</span><span class="n">this</span><span class="o">.</span><span class="n">H2</span><span class="s1">&#39;;</span>
<span class="k">if</span> <span class="n">isa</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="s1">&#39;LinOpDiag&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">T</span><span class="o">.</span><span class="n">isScaledIdentity</span>
     <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">diag</span><span class="o">&gt;</span><span class="mi">0</span>
          <span class="n">this</span><span class="o">.</span><span class="n">isH2SemiOrtho</span><span class="o">=</span><span class="n">true</span><span class="p">;</span>
          <span class="n">this</span><span class="o">.</span><span class="n">nu</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">diag</span><span class="p">;</span>
     <span class="n">end</span>
<span class="n">end</span>
</pre></div>
</div>
<p>and in the <code class="xref py py-meth docutils literal"><span class="pre">applyProx()</span></code> implementation</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">x</span><span class="o">=</span><span class="n">applyProx_</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">this</span><span class="o">.</span><span class="n">isConvex</span> <span class="o">&amp;&amp;</span> <span class="n">this</span><span class="o">.</span><span class="n">isH2LinOp</span> <span class="o">&amp;&amp;</span> <span class="n">this</span><span class="o">.</span><span class="n">isH2SemiOrtho</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">this</span><span class="o">.</span><span class="n">nu</span><span class="o">*</span><span class="n">this</span><span class="o">.</span><span class="n">H2</span><span class="o">.</span><span class="n">applyAdjoint</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">H1</span><span class="o">.</span><span class="n">applyProx</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">H2</span><span class="o">*</span><span class="n">z</span><span class="p">,</span><span class="n">alpha</span><span class="o">*</span><span class="n">this</span><span class="o">.</span><span class="n">nu</span><span class="p">)</span><span class="o">-</span><span class="n">this</span><span class="o">.</span><span class="n">H2</span><span class="o">*</span><span class="n">z</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">applyProx_</span><span class="nd">@Cost</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">alpha</span><span class="p">);</span>
    <span class="n">end</span>
<span class="n">end</span>
</pre></div>
</div>
<p>As a result, in the library, combining any <code class="xref py py-class docutils literal"><span class="pre">Cost</span></code> having an implementation of <code class="xref py py-meth docutils literal"><span class="pre">applyProx()</span></code> with a <code class="xref py py-class docutils literal"><span class="pre">LinOp</span></code>
which is semi-orthogonal (its <code class="xref py py-meth docutils literal"><span class="pre">makeHHt()</span></code> returns a <code class="xref py py-class docutils literal"><span class="pre">LinOpDiag</span></code> with a constant diagonal) results in a new
<code class="xref py py-class docutils literal"><span class="pre">Cost</span></code> which has an implementation of <code class="xref py py-meth docutils literal"><span class="pre">applyProx()</span></code>.</p>
<p><strong>Important</strong> The use of this operator algebra is not recommended for implementing methods  since it creates at each call
a new object which may slow the computation of iterative algorithms. However, it can be
used in the constructor method or in other methods as a default implementation.</p>
</div>
<div class="section" id="auxiliary-utilities">
<h2>Auxiliary Utilities<a class="headerlink" href="#auxiliary-utilities" title="Permalink to this headline">¶</a></h2>
<p>The library contains a folder <em>Util/</em> with several function. These include viewvers or checking functions which give a
first control that an implementation is correct. For instance, the <strong>CheckMap</strong> function verifies some basic relations
between the different methods implemented in the given <code class="xref py py-class docutils literal"><span class="pre">Map</span></code>.</p>
<div class="code matlab highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">H</span><span class="o">=</span><span class="n">LinOpConv</span><span class="p">(</span><span class="n">fft2</span><span class="p">(</span><span class="n">psf</span><span class="p">));</span>
<span class="o">&gt;&gt;</span> <span class="n">checkMap</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="o">--</span> <span class="n">Checking</span> <span class="n">Map</span> <span class="k">with</span> <span class="n">name</span> <span class="n">LinOpConv</span><span class="o">--</span>
    <span class="n">apply</span> <span class="n">OK</span>
    <span class="n">applyJacobianT</span> <span class="n">OK</span>
    <span class="n">applyInverse</span> <span class="n">OK</span>
        <span class="n">SNR</span><span class="p">:</span> <span class="mi">296</span> <span class="n">dB</span><span class="p">,</span> <span class="n">OK</span>
<span class="o">--</span> <span class="n">LinOp</span><span class="o">-</span><span class="n">specific</span> <span class="n">checks</span> <span class="o">--</span>
    <span class="n">applyAdjoint</span> <span class="n">OK</span>
        <span class="n">SNR</span><span class="p">:</span> <span class="mi">306</span> <span class="n">dB</span><span class="p">,</span> <span class="n">OK</span>
    <span class="n">applyHtH</span> <span class="n">OK</span>
        <span class="n">SNR</span><span class="p">:</span> <span class="mi">318</span> <span class="n">dB</span><span class="p">,</span> <span class="n">OK</span>
    <span class="n">applyHHt</span> <span class="n">OK</span>
        <span class="n">SNR</span><span class="p">:</span> <span class="mi">331</span> <span class="n">dB</span><span class="p">,</span> <span class="n">OK</span>
</pre></div>
</div>
</div>
<div class="section" id="use-the-provided-templates">
<h2>Use the provided templates!<a class="headerlink" href="#use-the-provided-templates" title="Permalink to this headline">¶</a></h2>
<p>Templates for implementing new <code class="xref py py-class docutils literal"><span class="pre">Map</span></code>, <code class="xref py py-class docutils literal"><span class="pre">LinOp</span></code>, <code class="xref py py-class docutils literal"><span class="pre">Cost</span></code> or <code class="xref py py-class docutils literal"><span class="pre">Opti</span></code> are provided to help developers.
They can be found under the names:</p>
<blockquote>
<div><ul class="simple">
<li>TemplateMap.m</li>
<li>TemplateLinOp.m</li>
<li>TemplateCost.m</li>
<li>TemplateOpti.m</li>
</ul>
</div></blockquote>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to the GlobalBioIm Library webpage!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Biomedical Imaging Group (EPFL).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>